/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.14.2.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Addr, Uint128, Timestamp, Uint64, SlotType, AgentStatus, CosmosMsgForEmpty, BankMsg, StakingMsg, DistributionMsg, Binary, IbcMsg, WasmMsg, GovMsg, VoteOption, Boundary, Interval, Rule, Balance, NativeBalance, Status, ValueIndex, ValueOrdering, Croncat, Agent, GenericBalance, Cw20CoinVerified, Coin, GetBalancesResponse, GetConfigResponse, GetAgentIdsResponse, AgentResponse, AgentTaskResponse, GetSlotHashesResponse, GetSlotIdsResponse, TaskResponse, ActionForEmpty, Empty, IbcTimeout, IbcTimeoutBlock, HasBalanceGte, CheckOwnerOfNft, CheckProposalStatus, GenericQuery, GetWalletBalancesResponse, Task, BoundaryValidated, TaskRequest, Cw20Coin, ExecuteMsg, Cw20ReceiveMsg, GetAgentResponse, GetAgentTasksResponse, RoundRobinBalancerModeResponse, GetStateResponse, BalancesResponse, SlotResponse, SlotWithRuleResponse, ReplyQueueResponse, QueueItemResponse, TaskWithRulesResponse, GetTaskHashResponse, GetTaskResponse, GetTasksByOwnerResponse, GetTasksResponse, GetTasksWithRulesResponse, InstantiateMsg, QueryMsg, ValidateIntervalResponse } from "./CwCroncat.types";
import { CwCroncatQueryClient, CwCroncatClient } from "./CwCroncat.client";
export const cwCroncatQueryKeys = {
  contract: ([{
    contract: "cwCroncat"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...cwCroncatQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  getConfig: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwCroncatQueryKeys.address(contractAddress)[0],
    method: "get_config",
    args
  }] as const),
  getBalances: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwCroncatQueryKeys.address(contractAddress)[0],
    method: "get_balances",
    args
  }] as const),
  getAgent: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwCroncatQueryKeys.address(contractAddress)[0],
    method: "get_agent",
    args
  }] as const),
  getAgentIds: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwCroncatQueryKeys.address(contractAddress)[0],
    method: "get_agent_ids",
    args
  }] as const),
  getAgentTasks: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwCroncatQueryKeys.address(contractAddress)[0],
    method: "get_agent_tasks",
    args
  }] as const),
  getTasks: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwCroncatQueryKeys.address(contractAddress)[0],
    method: "get_tasks",
    args
  }] as const),
  getTasksWithRules: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwCroncatQueryKeys.address(contractAddress)[0],
    method: "get_tasks_with_rules",
    args
  }] as const),
  getTasksByOwner: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwCroncatQueryKeys.address(contractAddress)[0],
    method: "get_tasks_by_owner",
    args
  }] as const),
  getTask: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwCroncatQueryKeys.address(contractAddress)[0],
    method: "get_task",
    args
  }] as const),
  getTaskHash: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwCroncatQueryKeys.address(contractAddress)[0],
    method: "get_task_hash",
    args
  }] as const),
  validateInterval: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwCroncatQueryKeys.address(contractAddress)[0],
    method: "validate_interval",
    args
  }] as const),
  getSlotHashes: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwCroncatQueryKeys.address(contractAddress)[0],
    method: "get_slot_hashes",
    args
  }] as const),
  getSlotIds: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwCroncatQueryKeys.address(contractAddress)[0],
    method: "get_slot_ids",
    args
  }] as const),
  getWalletBalances: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwCroncatQueryKeys.address(contractAddress)[0],
    method: "get_wallet_balances",
    args
  }] as const),
  getState: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwCroncatQueryKeys.address(contractAddress)[0],
    method: "get_state",
    args
  }] as const)
};
export interface CwCroncatReactQuery<TResponse, TData = TResponse> {
  client: CwCroncatQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface CwCroncatGetStateQuery<TData> extends CwCroncatReactQuery<GetStateResponse, TData> {
  args: {
    fromIndex?: number;
    limit?: number;
  };
}
export function useCwCroncatGetStateQuery<TData = GetStateResponse>({
  client,
  args,
  options
}: CwCroncatGetStateQuery<TData>) {
  return useQuery<GetStateResponse, Error, TData>(cwCroncatQueryKeys.getState(client?.contractAddress, args), () => client ? client.getState({
    fromIndex: args.fromIndex,
    limit: args.limit
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwCroncatGetWalletBalancesQuery<TData> extends CwCroncatReactQuery<GetWalletBalancesResponse, TData> {
  args: {
    wallet: string;
  };
}
export function useCwCroncatGetWalletBalancesQuery<TData = GetWalletBalancesResponse>({
  client,
  args,
  options
}: CwCroncatGetWalletBalancesQuery<TData>) {
  return useQuery<GetWalletBalancesResponse, Error, TData>(cwCroncatQueryKeys.getWalletBalances(client?.contractAddress, args), () => client ? client.getWalletBalances({
    wallet: args.wallet
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwCroncatGetSlotIdsQuery<TData> extends CwCroncatReactQuery<GetSlotIdsResponse, TData> {}
export function useCwCroncatGetSlotIdsQuery<TData = GetSlotIdsResponse>({
  client,
  options
}: CwCroncatGetSlotIdsQuery<TData>) {
  return useQuery<GetSlotIdsResponse, Error, TData>(cwCroncatQueryKeys.getSlotIds(client?.contractAddress), () => client ? client.getSlotIds() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwCroncatGetSlotHashesQuery<TData> extends CwCroncatReactQuery<GetSlotHashesResponse, TData> {
  args: {
    slot?: number;
  };
}
export function useCwCroncatGetSlotHashesQuery<TData = GetSlotHashesResponse>({
  client,
  args,
  options
}: CwCroncatGetSlotHashesQuery<TData>) {
  return useQuery<GetSlotHashesResponse, Error, TData>(cwCroncatQueryKeys.getSlotHashes(client?.contractAddress, args), () => client ? client.getSlotHashes({
    slot: args.slot
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwCroncatValidateIntervalQuery<TData> extends CwCroncatReactQuery<ValidateIntervalResponse, TData> {
  args: {
    interval: Interval;
  };
}
export function useCwCroncatValidateIntervalQuery<TData = ValidateIntervalResponse>({
  client,
  args,
  options
}: CwCroncatValidateIntervalQuery<TData>) {
  return useQuery<ValidateIntervalResponse, Error, TData>(cwCroncatQueryKeys.validateInterval(client?.contractAddress, args), () => client ? client.validateInterval({
    interval: args.interval
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwCroncatGetTaskHashQuery<TData> extends CwCroncatReactQuery<GetTaskHashResponse, TData> {
  args: {
    task: Task;
  };
}
export function useCwCroncatGetTaskHashQuery<TData = GetTaskHashResponse>({
  client,
  args,
  options
}: CwCroncatGetTaskHashQuery<TData>) {
  return useQuery<GetTaskHashResponse, Error, TData>(cwCroncatQueryKeys.getTaskHash(client?.contractAddress, args), () => client ? client.getTaskHash({
    task: args.task
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwCroncatGetTaskQuery<TData> extends CwCroncatReactQuery<GetTaskResponse, TData> {
  args: {
    taskHash: string;
  };
}
export function useCwCroncatGetTaskQuery<TData = GetTaskResponse>({
  client,
  args,
  options
}: CwCroncatGetTaskQuery<TData>) {
  return useQuery<GetTaskResponse, Error, TData>(cwCroncatQueryKeys.getTask(client?.contractAddress, args), () => client ? client.getTask({
    taskHash: args.taskHash
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwCroncatGetTasksByOwnerQuery<TData> extends CwCroncatReactQuery<GetTasksByOwnerResponse, TData> {
  args: {
    ownerId: string;
  };
}
export function useCwCroncatGetTasksByOwnerQuery<TData = GetTasksByOwnerResponse>({
  client,
  args,
  options
}: CwCroncatGetTasksByOwnerQuery<TData>) {
  return useQuery<GetTasksByOwnerResponse, Error, TData>(cwCroncatQueryKeys.getTasksByOwner(client?.contractAddress, args), () => client ? client.getTasksByOwner({
    ownerId: args.ownerId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwCroncatGetTasksWithRulesQuery<TData> extends CwCroncatReactQuery<GetTasksWithRulesResponse, TData> {
  args: {
    fromIndex?: number;
    limit?: number;
  };
}
export function useCwCroncatGetTasksWithRulesQuery<TData = GetTasksWithRulesResponse>({
  client,
  args,
  options
}: CwCroncatGetTasksWithRulesQuery<TData>) {
  return useQuery<GetTasksWithRulesResponse, Error, TData>(cwCroncatQueryKeys.getTasksWithRules(client?.contractAddress, args), () => client ? client.getTasksWithRules({
    fromIndex: args.fromIndex,
    limit: args.limit
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwCroncatGetTasksQuery<TData> extends CwCroncatReactQuery<GetTasksResponse, TData> {
  args: {
    fromIndex?: number;
    limit?: number;
  };
}
export function useCwCroncatGetTasksQuery<TData = GetTasksResponse>({
  client,
  args,
  options
}: CwCroncatGetTasksQuery<TData>) {
  return useQuery<GetTasksResponse, Error, TData>(cwCroncatQueryKeys.getTasks(client?.contractAddress, args), () => client ? client.getTasks({
    fromIndex: args.fromIndex,
    limit: args.limit
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwCroncatGetAgentTasksQuery<TData> extends CwCroncatReactQuery<GetAgentTasksResponse, TData> {
  args: {
    accountId: string;
  };
}
export function useCwCroncatGetAgentTasksQuery<TData = GetAgentTasksResponse>({
  client,
  args,
  options
}: CwCroncatGetAgentTasksQuery<TData>) {
  return useQuery<GetAgentTasksResponse, Error, TData>(cwCroncatQueryKeys.getAgentTasks(client?.contractAddress, args), () => client ? client.getAgentTasks({
    accountId: args.accountId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwCroncatGetAgentIdsQuery<TData> extends CwCroncatReactQuery<GetAgentIdsResponse, TData> {}
export function useCwCroncatGetAgentIdsQuery<TData = GetAgentIdsResponse>({
  client,
  options
}: CwCroncatGetAgentIdsQuery<TData>) {
  return useQuery<GetAgentIdsResponse, Error, TData>(cwCroncatQueryKeys.getAgentIds(client?.contractAddress), () => client ? client.getAgentIds() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwCroncatGetAgentQuery<TData> extends CwCroncatReactQuery<GetAgentResponse, TData> {
  args: {
    accountId: string;
  };
}
export function useCwCroncatGetAgentQuery<TData = GetAgentResponse>({
  client,
  args,
  options
}: CwCroncatGetAgentQuery<TData>) {
  return useQuery<GetAgentResponse, Error, TData>(cwCroncatQueryKeys.getAgent(client?.contractAddress, args), () => client ? client.getAgent({
    accountId: args.accountId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwCroncatGetBalancesQuery<TData> extends CwCroncatReactQuery<GetBalancesResponse, TData> {}
export function useCwCroncatGetBalancesQuery<TData = GetBalancesResponse>({
  client,
  options
}: CwCroncatGetBalancesQuery<TData>) {
  return useQuery<GetBalancesResponse, Error, TData>(cwCroncatQueryKeys.getBalances(client?.contractAddress), () => client ? client.getBalances() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwCroncatGetConfigQuery<TData> extends CwCroncatReactQuery<GetConfigResponse, TData> {}
export function useCwCroncatGetConfigQuery<TData = GetConfigResponse>({
  client,
  options
}: CwCroncatGetConfigQuery<TData>) {
  return useQuery<GetConfigResponse, Error, TData>(cwCroncatQueryKeys.getConfig(client?.contractAddress), () => client ? client.getConfig() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwCroncatWithdrawWalletBalanceMutation {
  client: CwCroncatClient;
  msg: {
    cw20Amounts: Cw20Coin[];
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwCroncatWithdrawWalletBalanceMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwCroncatWithdrawWalletBalanceMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwCroncatWithdrawWalletBalanceMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.withdrawWalletBalance(msg, fee, memo, funds), options);
}
export interface CwCroncatReceiveMutation {
  client: CwCroncatClient;
  msg: Cw20ReceiveMsg;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwCroncatReceiveMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwCroncatReceiveMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwCroncatReceiveMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.receive(msg, fee, memo, funds), options);
}
export interface CwCroncatProxyCallMutation {
  client: CwCroncatClient;
  msg: {
    taskHash?: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwCroncatProxyCallMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwCroncatProxyCallMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwCroncatProxyCallMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.proxyCall(msg, fee, memo, funds), options);
}
export interface CwCroncatRefillTaskCw20BalanceMutation {
  client: CwCroncatClient;
  msg: {
    cw20Coins: Cw20Coin[];
    taskHash: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwCroncatRefillTaskCw20BalanceMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwCroncatRefillTaskCw20BalanceMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwCroncatRefillTaskCw20BalanceMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.refillTaskCw20Balance(msg, fee, memo, funds), options);
}
export interface CwCroncatRefillTaskBalanceMutation {
  client: CwCroncatClient;
  msg: {
    taskHash: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwCroncatRefillTaskBalanceMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwCroncatRefillTaskBalanceMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwCroncatRefillTaskBalanceMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.refillTaskBalance(msg, fee, memo, funds), options);
}
export interface CwCroncatRemoveTaskMutation {
  client: CwCroncatClient;
  msg: {
    taskHash: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwCroncatRemoveTaskMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwCroncatRemoveTaskMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwCroncatRemoveTaskMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.removeTask(msg, fee, memo, funds), options);
}
export interface CwCroncatCreateTaskMutation {
  client: CwCroncatClient;
  msg: {
    task: TaskRequest;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwCroncatCreateTaskMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwCroncatCreateTaskMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwCroncatCreateTaskMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.createTask(msg, fee, memo, funds), options);
}
export interface CwCroncatWithdrawRewardMutation {
  client: CwCroncatClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwCroncatWithdrawRewardMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwCroncatWithdrawRewardMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwCroncatWithdrawRewardMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.withdrawReward(fee, memo, funds), options);
}
export interface CwCroncatUnregisterAgentMutation {
  client: CwCroncatClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwCroncatUnregisterAgentMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwCroncatUnregisterAgentMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwCroncatUnregisterAgentMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.unregisterAgent(fee, memo, funds), options);
}
export interface CwCroncatCheckInAgentMutation {
  client: CwCroncatClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwCroncatCheckInAgentMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwCroncatCheckInAgentMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwCroncatCheckInAgentMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.checkInAgent(fee, memo, funds), options);
}
export interface CwCroncatUpdateAgentMutation {
  client: CwCroncatClient;
  msg: {
    payableAccountId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwCroncatUpdateAgentMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwCroncatUpdateAgentMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwCroncatUpdateAgentMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateAgent(msg, fee, memo, funds), options);
}
export interface CwCroncatRegisterAgentMutation {
  client: CwCroncatClient;
  msg: {
    payableAccountId?: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwCroncatRegisterAgentMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwCroncatRegisterAgentMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwCroncatRegisterAgentMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.registerAgent(msg, fee, memo, funds), options);
}
export interface CwCroncatMoveBalancesMutation {
  client: CwCroncatClient;
  msg: {
    accountId: string;
    balances: Balance[];
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwCroncatMoveBalancesMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwCroncatMoveBalancesMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwCroncatMoveBalancesMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.moveBalances(msg, fee, memo, funds), options);
}
export interface CwCroncatUpdateSettingsMutation {
  client: CwCroncatClient;
  msg: {
    agentFee?: Coin;
    agentsEjectThreshold?: number;
    gasPrice?: number;
    minTasksPerAgent?: number;
    ownerId?: string;
    paused?: boolean;
    proxyCallbackGas?: number;
    slotGranularity?: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwCroncatUpdateSettingsMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwCroncatUpdateSettingsMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwCroncatUpdateSettingsMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateSettings(msg, fee, memo, funds), options);
}